<html>
    <head>
        <meta charset="UTF-8" />
        <title>ä»£ç†è½¬æ¢</title>
        <style>
            body {
                font-family: sans-serif;
                margin: 20px;
            }
            .header-link {
                float: right;
                margin-bottom: 20px;
            }
            .header-link a {
                display: flex;
                align-items: center;
                text-decoration: none;
                color: #000; /* å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´é¢œè‰² */
            }
            .header-link img {
                margin-right: 5px;
            }
            textarea {
                width: 100%;
                height: 200px;
                margin-bottom: 10px;
                padding: 10px;
                box-sizing: border-box;
                border: 1px solid #ccc;
                border-radius: 4px;
                clear: both; /* ç¡®ä¿å®ƒåœ¨æµ®åŠ¨å…ƒç´ ä¸‹æ–¹ */
            }
            button {
                margin: 10px 0;
                padding: 10px 20px;
                background-color: #007bff;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }
            button:hover {
                background-color: #0056b3;
            }
            p {
                margin-top: 20px;
                margin-bottom: 5px;
                font-weight: bold;
            }
        </style>
        <script src="test.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    </head>
    <body>
        <div style="margin-bottom: 20px; overflow: hidden;">
            <div style="float: left;">
                <a href="url_to_qrcode.html" style="text-decoration: none; color: #007bff;">
                    ğŸ“± äºŒç»´ç ç”Ÿæˆå™¨
                </a>
            </div>
            <div class="header-link">
                <a href="https://github.com/wynemo/v2ray-to-sing-box" target="_blank">
                    <img src="https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png" alt="GitHub" width="30" height="30">
                    v2ray-to-sing-box
                </a>
            </div>
        </div>
        <textarea
            id="input"
            placeholder="è¯·è¾“å…¥å¾…è½¬æ¢çš„ä»£ç†é…ç½® æ”¯æŒv2ray/clashæ ¼å¼ æˆ–è€…å¤šè¡ŒURI"
        ></textarea>
        <button onclick="convert()">è½¬æ¢</button>
        <textarea id="output" readonly></textarea>
        <p>Base64 decode ç»“æœ</p>
        <textarea
            id="decodedOutput"
            placeholder="Base64 è§£ç ç»“æœ"
            readonly
        ></textarea>
        <p>URI æ ¼å¼è¾“å‡º</p>
        <textarea
            id="uriOutput"
            placeholder="URI æ ¼å¼è¾“å‡º"
            readonly
        ></textarea>

        <script>
            function isValidSubYAML(str) {
                if (typeof str !== "string") return false;
                try {
                    //çœ‹æ˜¯ä¸æ˜¯æœ‰ proxies
                    const { proxies } = jsyaml.load(str);
                    //åŒæ„Ÿå¹å· `!!` æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„ç¼–ç¨‹æŠ€å·§ï¼Œç”¨æ¥å°†ä¸€ä¸ªå€¼å¼ºåˆ¶è½¬æ¢ä¸ºå¸ƒå°”ç±»å‹ï¼ˆbooleanï¼‰
                    return !!proxies;
                } catch {
                    return false;
                }
            }

            // åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ Base64
            function isValidBase64(str) {
                try {
                    return btoa(atob(str)) === str;
                } catch (err) {
                    return false;
                }
            }
            // Base64 è§£ç 
            function base64Decode(str) {
                try {
                    return decodeURIComponent(escape(atob(str)));
                } catch (err) {
                    return atob(str);
                }
            }
            
            // ç®€åŒ–çš„ URI ç”Ÿæˆå‡½æ•°
            function simpleGenerateURI(proxy) {
                const name = encodeURIComponent(proxy.name || '');
                
                switch (proxy.type) {
                    case 'vmess':
                        const vmessConfig = {
                            v: "2",
                            ps: proxy.name || '',
                            add: proxy.server,
                            port: proxy.port,
                            id: proxy.uuid,
                            aid: proxy.alterId || 0,
                            scy: proxy.cipher || 'auto',
                            net: proxy.network || 'tcp',
                            type: 'none',
                            host: proxy['ws-opts']?.headers?.Host || proxy['http-opts']?.headers?.Host || '',
                            path: proxy['ws-opts']?.path || proxy['http-opts']?.path || proxy['grpc-opts']?.['grpc-service-name'] || '',
                            tls: proxy.tls ? 'tls' : '',
                            sni: proxy.sni || ''
                        };
                        return `vmess://${btoa(JSON.stringify(vmessConfig))}`;
                    
                    case 'vless':
                        const vlessParams = new URLSearchParams();
                        if (proxy.tls) vlessParams.append('security', 'tls');
                        if (proxy.sni) vlessParams.append('sni', proxy.sni);
                        if (proxy.network && proxy.network !== 'tcp') vlessParams.append('type', proxy.network);
                        if (proxy.flow) vlessParams.append('flow', proxy.flow);
                        const vlessQuery = vlessParams.toString();
                        return `vless://${proxy.uuid}@${proxy.server}:${proxy.port}${vlessQuery ? '?' + vlessQuery : ''}#${name}`;
                    
                    case 'trojan':
                        const trojanParams = new URLSearchParams();
                        if (proxy.sni) trojanParams.append('sni', proxy.sni);
                        const trojanQuery = trojanParams.toString();
                        return `trojan://${proxy.password}@${proxy.server}:${proxy.port}${trojanQuery ? '?' + trojanQuery : ''}#${name}`;
                    
                    case 'ss':
                        const ssAuth = btoa(`${proxy.cipher}:${proxy.password}`);
                        return `ss://${ssAuth}@${proxy.server}:${proxy.port}#${name}`;
                    
                    case 'hysteria2':
                        const hy2Params = new URLSearchParams();
                        if (proxy.sni) hy2Params.append('sni', proxy.sni);
                        const hy2Query = hy2Params.toString();
                        return `hysteria2://${proxy.password}@${proxy.server}:${proxy.port}${hy2Query ? '?' + hy2Query : ''}#${name}`;
                    
                    default:
                        return null;
                }
            }
            function convert() {
                try {
                    let input = document.getElementById("input").value.trim();
                    let lines;

                    let proxies = [];

                    let decodedText = "";

                    if (isValidSubYAML(input)) {
                        // å¦‚æœæ˜¯ yamlï¼Œè®¤ä¸ºæ˜¯ clash æ ¼å¼çš„
                        proxies = jsyaml.load(input).proxies;
                        lines = [];
                    } else if (isValidBase64(input)) {
                        // å¦‚æœæ˜¯ base64ï¼Œè®¤ä¸ºæ˜¯ v2ray æ ¼å¼çš„
                        decodedText = base64Decode(input);
                        lines = decodedText.split("\n").filter((v) => v);
                    } else {
                        // å¦‚æœæ˜¯å…¶ä»–æ ¼å¼ï¼Œè®¤ä¸ºæ˜¯å•è¡Œçš„èŠ‚ç‚¹ä¿¡æ¯
                        lines = input.split("\n").filter((v) => v);
                    }

                    for (let line of lines) {
                        const schema = line.split("://")[0];
                        const protocol = protocolForClash[schema.toLowerCase()];
                        if (!protocol) {
                            console.log(`æœªæ”¯æŒçš„åè®®ï¼š${schema}`);
                            continue;
                        }
                        try {
                            const proxy = protocol.parse(line);
                            proxies.push(proxy);
                        } catch (error) {
                            console.log("è§£æé”™è¯¯ï¼š", error);
                        }
                    }

                    const singbox_proxies = [];

                    const protocolForSingBoxMap = protocolForSingBox();
                    for (let proxy of proxies) {
                        try {
                            const _proxy =
                                protocolForSingBoxMap[proxy.type](proxy);
                            singbox_proxies.push(_proxy);
                        } catch (error) {
                            console.log("è§£æé”™è¯¯ SingBox èŠ‚ç‚¹", error);
                        }
                    }

                    console.log("singbox", singbox_proxies);

                    document.getElementById("output").value = JSON.stringify(
                        singbox_proxies,
                        null,
                        2,
                    );
                    document.getElementById("decodedOutput").value = decodedText;
                    
                    // ç”Ÿæˆ URI æ ¼å¼è¾“å‡º
                    const uriLines = [];
                    for (let proxy of proxies) {
                        try {
                            const uri = simpleGenerateURI(proxy);
                            if (uri) {
                                uriLines.push(uri);
                            }
                        } catch (error) {
                            console.log("ç”Ÿæˆ URI é”™è¯¯ï¼š", error);
                        }
                    }
                    document.getElementById("uriOutput").value = uriLines.join('\n');
                } catch (error) {
                    console.error("è½¬æ¢å¤±è´¥ï¼š", error);
                }
            }
        </script>
    </body>
</html>
